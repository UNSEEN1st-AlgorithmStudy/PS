//내가 푼 코드
//#include <iostream>
//
//using namespace std;
//
//int house[1001][4] = {};
//
//int main()
//{
//	int n = 0;
//	cin >> n;
//
//	for (int i = 1; i <= n; ++i)
//	{
//		for (int j = 1; j <= 3; ++j)
//		{
//			cin >> house[i][j];
//		}
//	}
//
//	return 0;
//}

//답을 보고 수정한 코드.
#include <iostream>
#include <algorithm>

using namespace std;

int house[1001][3];

int main()
{
	int n = 0;
	cin >> n;

	for (int i = 0; i < n; ++i)
	{
		for (int j = 0; j < 3; ++j)
		{
			cin >> house[i][j];
		}
	}

	//두번째 집을 R로 색칠을 하려면 첫번째 집이 B또는 G여야 함.
	//R로 색칠할 때 B또는 G로 색칠하는 비용 중에 비용이 적은 것으로 색칠을 하면 최소비용으로 두번째 집을 R로 색칠할 수 있다.
	//따라서 N번 째 집을 RGB중 하나로 색칠을 할 때, N - 1번 째 집에서 N번째에 색칠된 동일한 색과는 다른 색 2가지 중 색칠하는 비용이 적은 것으로 선택하면 최소비용을 선택할 수 있다.
	//이 과정을 N까지 반복하면 dp[n - 1][0], dp[n - 1][1], dp[n - 1][2] 중 제일 작은 값이 정답이 된다.
	for (int i = 1; i < n; i++)
	{
		house[i][0] += min(house[i - 1][1], house[i - 1][2]);
		house[i][1] += min(house[i - 1][0], house[i - 1][2]);
		house[i][2] += min(house[i - 1][0], house[i - 1][1]);
	}

	cout << min({ house[n - 1][0], house[n - 1][1], house[n - 1][2] });
}

//결과
//오늘도 못풀었습니다. 하하!
//이러다간 아마 스터디 끝날 때까지 혼자 못풀 거 같네요.
//안되면 될 때까지라는 마음으로 계속 따라가보겠습니다.

//어려운 점.
//풀이는 그닥 어렵지 않은 거 같은데 지문을 이해하지 못했다. (1번은 뭐고 n번은 뭐야? 뭐가 다른 거야)
//->그래서 점화식 못세움. 하하!
//오늘 컨디션 난조로 집중을 너무 못했다. (응 핑계~)

//꺠달은 점.
//블로그를 보니 문제를 쪼개는 게 중요하다고 한다.
//->머리로는 알고 있지만 막상 풀 때는 잘 와닿지 않는다.
//여타 코테가 다 그렇지만 DP는 특히 논리력이 중요한 거 같다.
